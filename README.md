# AI-Powered Content Generation Platform

## Description
The AI Content Generation Hub is a Spring Boot-based API that can be used to generate, analyze, and optimize various types of content using integrated AI services. The API leverages AI for natural language generation, image generation, text summarization, and sentiment analysis by integrating with popular AI tools like OpenAI's API and Google Cloud's NLP.

## Core features
* **Text generation**
Users can input a topic or keywords, and the system generates blog posts, product descriptions, or other types of text content.

  **_Integration:_** OpenAI API


* **Discussions**
Users can start and continue a discussion using prompts.

  **_Integration:_** OpenAI API


* **Text Summarization**
Users can input long documents or articles, and the system summarizes them into a shorter version.

  **_Integration:_** OpenAI API


* **Sentiment Analysis**
Analyze the tone and sentiment (positive, negative, or neutral) of the generated or user-provided text content.

  **_Integration:_** Google NLP


* **Image Generation**
Users can generate accompanying images for their text content (like blog cover images) using a text prompt.

  **_Integration:_** OpenAI DALL-E API

**(*)** _"Users" are the users of the API that can be a third party application (e.g. a web application)._

## Technologies and Libraries used
* **Spring Boot**: Core framework for building the RESTful API.
* **Spring Data JPA**: Object-relational mapping (ORM) for database interactions.
* **Spring Security**: For authentication and role-based access control (optional, if security features are included).
* **H2/PostgreSQL/MySQL**: Database options for storing client, project, task, and invoice data.
* **Jackson**: Handles JSON serialization and deserialization.
* **Swagger/OpenAPI**: Provides interactive API documentation.

## Entities

### 1. GeneratedContent (Message)
Represents generated content within the system. This entity is used to store content created during user interactions, generated by various sources, and categorized by type, role, and source. The content may be associated with a specific user and optionally linked to a conversation.

### 2. Conversation
Represents a (multi-turn) conversation with a user. Each conversation can have multiple associated GeneratedContent instances, each one representing a message exchange with the user.

### 3. Image
Represents an entity for storing information about images that are associated with a specific user. It includes details about the text input used to generate the image, the URL of the generated image, the upload timestamp, and the user who uploaded it.

## Services

### OpenAI GPT-4 Service (Summarization and Text Generation)

### Google NLP Service (Sentiment Analysis)

### OpenAI DALLÂ·E Service (Image Generation)


## API Endpoints

### AI Controller

A REST controller for AI-related functionalities, providing endpoints for text generation, conversation handling, text summarization, sentiment analysis and image generation using various third-party AI services.

* `POST /ai/start-conversation` : Endpoint to start a new conversation using OpenAI.
* `POST /ai/do-conversation?conversationId={{conversationId}}` : Endpoint to generate text for an ongoing conversation using OpenAI, by providing the ongoing {conversationId} as parameter.
* `POST /ai/generate-text` : Endpoint to generate text using OpenAI. User enters some text and AI generates a 'single' response to that text. Each text generation request is independent and stateless. It is not linked to any conversation.
* `POST /ai/summarize` : Endpoint to summarize text using OpenAI.
* `POST /ai/analyze-sentiment` : Endpoint to analyze sentiment of text using Google NLP.
* `POST /ai/generate-image` : Endpoint to generate an image using OpenAI's DALL-E API.

### Authentication Controller

Used for authentication-related operations, including user login and token refreshing.

* `POST /auth/login`: Authenticates a user based on the provided credentials and returns access and refresh tokens.
* `POST /auth/refresh-token`: Refreshes the access token using the provided refresh token. Validates the refresh token, extracts user information, and generates a new access token if valid.

### User Controller

Provides an endpoint for user registration.

* `POST /user/register`: Registers a new user by processing the provided user registration details.

## AI Tools and Platforms

## Security
### Authentication

The API is protected using JWT (JSON Web Token) for token-based authentication, involving both access tokens (short-lived) and refresh tokens (long-lived).

* **Access tokens**: Used for short-term access to protected resources (e.g., 15 minutes).
* **Refresh tokens**: Used to request new access tokens when the current one expires (e.g., 7 days).

### JWT Authentication Flow

#### 1. Login and Access Token Request

* User makes a `POST` request to `/auth/login` with a username and password.
* Upon successful authentication, the response includes two tokens:
    * Access token (short-lived).
    * Refresh token (long-lived).

Example:
`POST /auth/login`
```json
{
  "username": "user",
  "password": "password"
}
```
Response:
```json
{
"accessToken": "eyJhbGciOiJIUzI1NiIsInR...",
"refreshToken": "eyJhbGciOiJIUzI1NiIsInR..."
}
```

#### 2. Using the Access Token for API Requests

* Attach the access token in the Authorization header to authenticate API requests:

`Authorization: Bearer <accessToken>`

#### 3. Refreshing the Access Token

* When the access token expires, request a new one using the refresh token.

`POST /auth/refresh-token`

`Refresh-Token: <refreshToken>`

Response:
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR..."
}
```
#### 4. Expired Refresh Token

* If the refresh token has expired, the user must log in again.

### Key Classes
* **SecurityConfig**: Configures security settings for Spring Security.
* **JwtAuthenticationFilter**: Intercepts and validates JWT tokens for authentication.
* **JwtUtils**: Provides utility methods for generating, parsing, and validating JWT tokens.
* **CustomUserDetails**: Custom implementation of UserDetails for Spring Security.
* **CustomUserDetailsService**: Loads user details from the database for authentication.
* **AuthController**: Provides APIs for login and token generation.

## Authorization
**TO DO**: Implement role based access control (RBAC) using Spring Security to restrict access to certain endpoints based on user roles.

Roles:
* **ROLE_USER**: Default role for authenticated users (read).
* **ROLE_ADMIN**: Admin role with additional privileges (create, update, delete, read).

## Exception Handling

**GlobalExceptionHandler**:

A centralized exception handler using @ControllerAdvice.

It captures exceptions and returns appropriate HTTP responses, such as 404 Not Found or 400 Bad Request.

**Issue**:

The TokenExpiredException and potentially other JWT-related exceptions may not be caught by the GlobalExceptionHandler and instead return a 401 Unauthorized response without specific messages.

This might be due to how Spring Security's OncePerRequestFilter (i.e., JwtAuthenticationFilter) handles exceptions.

**Solutions:**

* Handle exceptions within the JwtAuthenticationFilter (current approach).
* Propagate exceptions to the global exception handler (TO DO).

## API Documentation (Swagger/OpenAPI)

Interactive API documentation is generated using Swagger (SpringDoc OpenAPI). Swagger UI can be accessed at:
http://localhost:8080/swagger-ui.html